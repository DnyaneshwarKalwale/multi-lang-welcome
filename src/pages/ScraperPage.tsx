import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Search, Linkedin, Globe, Youtube, Copy, 
  Lightbulb, MessageSquare, Save, Loader2,
  FileText, ArrowRight, PlusCircle, Twitter, ImageIcon, Folder, Eye
} from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from '@/components/ui/tabs';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { toast } from 'sonner';
import axios from 'axios';
import { saveImageToGallery } from '@/utils/cloudinaryDirectUpload';
import { saveYouTubeVideo, YouTubeVideo as StoredYouTubeVideo } from '@/utils/youtubeStorage';
import { v4 as uuidv4 } from 'uuid';

// Scraper result interface
interface ScraperResult {
  content: string;
  keyPoints: string[];
  tone: string;
  suggestedHook: string;
  estimatedReadTime: number;
  wordCount: number;
}

// Tweet interface
interface Tweet {
  id: string;
  text: string;
  full_text?: string;
  created_at: string;
  public_metrics: {
    retweet_count: number;
    reply_count: number;
    like_count: number;
    quote_count: number;
  };
  author: {
    id: string;
    name: string;
    username: string;
    profile_image_url: string;
  };
  media?: {
    media_key: string;
    type: string;
    url: string;
    preview_image_url?: string;
    alt_text?: string;
    width?: number;
    height?: number;
  }[];
}

// Twitter result interface
interface TwitterResult {
  tweets: Tweet[];
  username: string;
  profileImageUrl?: string;
}

// YouTube transcript interface
interface YouTubeTranscript {
  videoId: string;
  transcript: string;
  language: string;
  isAutoGenerated: boolean;
}

// Add the YouTubeSearchResult interface
interface YouTubeSearchResult {
  videoId: string;
  title: string;
  thumbnail: string;
  channelName: string;
  channelId: string;
  duration: number;
  viewCount: number;
}

// Add the YouTubeVideo interface for channel videos
interface ChannelVideo {
  videoId: string;
  title: string;
  thumbnail: string;
  channelName: string;
  channelId: string;
  duration: number;
  uploadDate: string;
  url: string;
}

const ScraperPage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const [activeTab, setActiveTab] = useState('linkedin');
  const [inputUrl, setInputUrl] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<ScraperResult | null>(null);
  const [twitterResult, setTwitterResult] = useState<TwitterResult | null>(null);
  const [selectedTweets, setSelectedTweets] = useState<Set<string>>(new Set());
  const [youtubeTranscript, setYoutubeTranscript] = useState<YouTubeTranscript | null>(null);
  const [contentPreferences, setContentPreferences] = useState({
    format: 'short',
    tone: 'professional'
  });
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [linkedinContent, setLinkedinContent] = useState('');
  const [isGeneratingImage, setIsGeneratingImage] = useState(false);
  const [generatedContentImage, setGeneratedContentImage] = useState<string | null>(null);
  const [youtubeSearchResults, setYoutubeSearchResults] = useState<YouTubeSearchResult[]>([]);
  const [youtubeSearchQuery, setYoutubeSearchQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [youtubeVideos, setYoutubeVideos] = useState<ChannelVideo[]>([]);
  const [channelInput, setChannelInput] = useState('');
  const [isLoadingChannel, setIsLoadingChannel] = useState(false);
  const [channelName, setChannelName] = useState('');
  
  // Example result data for demonstration
  const exampleResult: ScraperResult = {
    content: "In today's digital landscape, content creation has become a cornerstone of successful marketing strategies. However, many businesses struggle with consistency and quality. Our recent study of 500 marketing professionals revealed that companies using AI-assisted content generation saw a 37% increase in engagement and a 22% reduction in content production time. The key findings suggest that human-AI collaboration produces the best results, with AI handling research and initial drafts while humans refine messaging and add authentic perspectives. This approach not only improves efficiency but also enhances content relevance across different platforms.",
    keyPoints: [
      "Companies using AI for content creation saw 37% higher engagement",
      "Human-AI collaboration produces better results than either alone",
      "Content production time reduced by 22% when using AI assistance",
      "Quality and consistency improved across multiple platforms"
    ],
    tone: "Professional, informative, data-driven",
    suggestedHook: "Our recent study of 500 marketing professionals revealed a surprising insight about AI-assisted content creation that could transform your engagement metrics...",
    estimatedReadTime: 2,
    wordCount: 120
  };

  // Process URL from input
  const handleScrape = async () => {
    if (!inputUrl) {
      toast.error('Please enter a valid URL');
      return;
    }
    
    setIsLoading(true);
    
    try {
      if (activeTab === 'twitter') {
        await handleTwitterScrape();
      } else if (activeTab === 'youtube') {
        await handleYouTubeScrape();
      } else {
        // Handle other platforms (existing code)
        await new Promise(resolve => setTimeout(resolve, 2000));
        setResult(exampleResult);
        toast.success('Content scraped successfully!');
      }
    } catch (error) {
      console.error(`Error scraping content from ${activeTab}:`, error);
      toast.error(`Failed to scrape content from ${activeTab}. Please try again.`);
    } finally {
      setIsLoading(false);
    }
  };

  // Twitter specific scraping logic
  const handleTwitterScrape = async () => {
    // Extract username from Twitter URL or direct input
    let username = inputUrl;
    
    // If it's a URL, extract the username
    if (inputUrl.includes('twitter.com/') || inputUrl.includes('x.com/')) {
      const urlParts = inputUrl.split('/');
      username = urlParts[urlParts.length - 1];
      
      // Clean up any query parameters
      username = username.split('?')[0];
    }
    
    // Remove @ symbol if present
    if (username.startsWith('@')) {
      username = username.substring(1);
    }
    
    if (!username) {
      toast.error('Please enter a valid Twitter username');
      return;
    }
    
    // Call backend API to get tweets
    const apiUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/api/twitter/user/${username}`;
    const response = await axios.get(apiUrl);
    
    if (response.data && response.data.success) {
      const tweets = response.data.data;
      
      setTwitterResult({
        tweets,
        username,
        profileImageUrl: tweets[0]?.author?.profile_image_url
      });
      
      toast.success(`Successfully retrieved ${tweets.length} tweets from @${username}`);
    } else {
      throw new Error(response.data?.message || 'Failed to fetch tweets');
    }
  };

  // YouTube specific scraping logic
  const handleYouTubeScrape = async (urlParam?: string) => {
    const videoUrl = urlParam || inputUrl;
    
    try {
      if (!videoUrl.includes('youtube.com') && !videoUrl.includes('youtu.be')) {
        toast.error('Please enter a valid YouTube URL');
        return;
      }
      
      // Check if it's a video URL or a channel URL
      if (videoUrl.includes('@') && !videoUrl.includes('watch?v=')) {
        // Extract channel name
        const channelName = videoUrl.includes('@') ? 
          videoUrl.split('@')[1].split('/')[0] : '';
        
        toast.error(
          <div>
            This appears to be a channel URL, not a video URL.
            <br />
            <button 
              className="underline text-blue-500 hover:text-blue-700"
              onClick={() => {
                setChannelInput(channelName);
                handleFetchChannelVideos();
              }}
            >
              Click here to search for videos from @{channelName}
            </button>
          </div>,
          {
            duration: 5000
          }
        );
        return;
      }
      
      setIsLoading(true);
      
      // Fix the API URL to remove duplicate /api/
      const baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
      // Make sure there's only one /api/ in the path
      const apiBaseUrl = baseUrl.endsWith('/api') ? baseUrl : `${baseUrl}/api`;
      
      // Call backend API to get transcript
      const apiUrl = `${apiBaseUrl}/youtube/transcript`;
      
      console.log('Fetching transcript from:', apiUrl);
      
      const response = await axios.get(apiUrl, {
        params: { url: videoUrl }
      });
      
      if (response.data && response.data.success) {
        const transcriptData = response.data.data;
        
        // Get video details
        const videoDetailsUrl = `${apiBaseUrl}/youtube/details`;
        const videoDetailsResponse = await axios.get(videoDetailsUrl, {
          params: { videoId: transcriptData.videoId }
        });
        
        let title = 'YouTube Video';
        let thumbnail = '';
        
        if (videoDetailsResponse.data && videoDetailsResponse.data.success) {
          title = videoDetailsResponse.data.data.title;
          thumbnail = videoDetailsResponse.data.data.thumbnail;
        }
        
        setYoutubeTranscript(transcriptData);
        setResult(null); // Clear any previous results
        setTwitterResult(null);
        
        toast.success('YouTube transcript fetched successfully!');
      } else {
        throw new Error(response.data?.message || 'Failed to fetch transcript');
      }
    } catch (error) {
      console.error('Error fetching YouTube transcript:', error);
      toast.error('Failed to fetch YouTube transcript. The video might not have captions or is unavailable.');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Analyze YouTube transcript for LinkedIn content
  const handleAnalyzeTranscript = async () => {
    if (!youtubeTranscript || !youtubeTranscript.transcript) {
      toast.error('No transcript available to analyze');
      return;
    }
    
    setIsAnalyzing(true);
    
    try {
      // Fix the API URL to remove duplicate /api/
      const baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
      // Make sure there's only one /api/ in the path
      const apiBaseUrl = baseUrl.endsWith('/api') ? baseUrl : `${baseUrl}/api`;
      
      // Call backend API to analyze transcript
      const apiUrl = `${apiBaseUrl}/youtube/analyze`;
      const response = await axios.post(apiUrl, {
        transcript: youtubeTranscript.transcript,
        preferences: contentPreferences
      });
      
      if (response.data && response.data.success) {
        const content = response.data.data.content;
        setLinkedinContent(content);
        
        // Get video details for saving
        const videoDetailsUrl = `${apiBaseUrl}/youtube/details`;
        const videoDetailsResponse = await axios.get(videoDetailsUrl, {
          params: { videoId: youtubeTranscript.videoId }
        });
        
        // Create and save the YouTube video data
        const videoToSave: StoredYouTubeVideo = {
          id: uuidv4(),
          videoId: youtubeTranscript.videoId,
          title: videoDetailsResponse?.data?.data?.title || `YouTube Video ${youtubeTranscript.videoId}`,
          thumbnail: videoDetailsResponse?.data?.data?.thumbnail || `https://img.youtube.com/vi/${youtubeTranscript.videoId}/maxresdefault.jpg`,
          transcript: youtubeTranscript.transcript,
          language: youtubeTranscript.language,
          isAutoGenerated: youtubeTranscript.isAutoGenerated,
          dateAdded: new Date().toISOString(),
          status: 'in_progress',
          slideCount: 5 // Default slide count
        };
        
        // Save to local storage
        saveYouTubeVideo(videoToSave);
        
        toast.success('Transcript analyzed and LinkedIn content generated!');
      } else {
        throw new Error(response.data?.message || 'Failed to analyze transcript');
      }
    } catch (error) {
      console.error('Error analyzing transcript:', error);
      toast.error('Failed to generate LinkedIn content from transcript.');
    } finally {
      setIsAnalyzing(false);
    }
  };

  // Copy content to clipboard
  const handleCopy = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success('Copied to clipboard!');
  };

  // Save to inspiration vault
  const handleSaveToInspiration = () => {
    if (youtubeTranscript) {
      // Fix the API URL to remove duplicate /api/
      const baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
      // Make sure there's only one /api/ in the path
      const apiBaseUrl = baseUrl.endsWith('/api') ? baseUrl : `${baseUrl}/api`;
      
      // Get video details
      const videoDetailsUrl = `${apiBaseUrl}/youtube/details`;
      axios.get(videoDetailsUrl, {
        params: { videoId: youtubeTranscript.videoId }
      }).then(response => {
        if (response.data && response.data.success) {
          // Create YouTube video object
          const videoToSave: StoredYouTubeVideo = {
            id: uuidv4(),
            videoId: youtubeTranscript.videoId,
            title: response.data.data.title,
            thumbnail: response.data.data.thumbnail,
            transcript: youtubeTranscript.transcript,
            language: youtubeTranscript.language,
            isAutoGenerated: youtubeTranscript.isAutoGenerated,
            dateAdded: new Date().toISOString(),
            status: 'in_progress',
            slideCount: 5 // Default slide count
          };
          
          // Save to local storage
          saveYouTubeVideo(videoToSave);
          
          toast.success('Saved to Inspiration Vault!');
        } else {
          // If video details can't be fetched, save with minimal info
          const videoToSave: StoredYouTubeVideo = {
            id: uuidv4(),
            videoId: youtubeTranscript.videoId,
            title: `YouTube Video ${youtubeTranscript.videoId}`,
            thumbnail: `https://img.youtube.com/vi/${youtubeTranscript.videoId}/maxresdefault.jpg`,
            transcript: youtubeTranscript.transcript,
            language: youtubeTranscript.language,
            isAutoGenerated: youtubeTranscript.isAutoGenerated,
            dateAdded: new Date().toISOString(),
            status: 'in_progress',
            slideCount: 5 // Default slide count
          };
          
          // Save to local storage
          saveYouTubeVideo(videoToSave);
          
          toast.success('Saved to Inspiration Vault!');
        }
      }).catch(error => {
        console.error('Error fetching video details:', error);
        toast.error('Failed to save video. Please try again.');
      });
    } else {
      toast.error('No YouTube content to save');
    }
  };

  // Create post from scraped content
  const handleCreatePost = () => {
    // In a real app, you would store the scraped content and redirect
    navigate('/dashboard/post');
  };

  // Toggle tweet selection
  const handleToggleTweetSelection = (tweetId: string) => {
    const newSelection = new Set(selectedTweets);
    
    if (newSelection.has(tweetId)) {
      newSelection.delete(tweetId);
    } else {
      newSelection.add(tweetId);
    }
    
    setSelectedTweets(newSelection);
  };

  // Save selected tweets
  const handleSaveSelectedTweets = async () => {
    if (selectedTweets.size === 0) {
      toast.error('Please select at least one tweet to save');
      return;
    }
    
    if (!twitterResult || !twitterResult.tweets) {
      toast.error('No tweets available to save');
      return;
    }
    
    setIsLoading(true);
    
    try {
      // Filter only selected tweets
      const tweetsToSave = twitterResult.tweets.filter(tweet => 
        selectedTweets.has(tweet.id)
      );
      
      // Call API to save tweets
      const apiUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/api/twitter/save`;
      
      const response = await axios.post(apiUrl, {
        tweets: tweetsToSave,
        username: user?.email || 'anonymous',
        options: {
          preserveThreadOrder: true
        }
      });
      
      if (response.data && response.data.success) {
        toast.success(`Saved ${response.data.count} tweets successfully!`);
        setSelectedTweets(new Set());
      } else {
        throw new Error(response.data?.message || 'Failed to save tweets');
      }
    } catch (error) {
      console.error('Error saving tweets:', error);
      toast.error('Failed to save tweets. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // Reset selection when tab changes
  useEffect(() => {
    setInputUrl('');
    setResult(null);
    setTwitterResult(null);
    setSelectedTweets(new Set());
  }, [activeTab]);

  // Add function to generate image from content
  const handleGenerateImageFromContent = async () => {
    if (!linkedinContent && !youtubeTranscript?.transcript) {
      toast.error('No content available to generate an image');
      return;
    }
    
    setIsGeneratingImage(true);
    
    try {
      const prompt = youtubeTranscript?.transcript.substring(0, 200) || linkedinContent.substring(0, 200);
      
      // Fix the API URL to remove duplicate /api/
      const baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
      // Make sure there's only one /api/ in the path
      const apiBaseUrl = baseUrl.endsWith('/api') ? baseUrl : `${baseUrl}/api`;
      
      const apiUrl = `${apiBaseUrl}/cloudinary/generate`;
      const response = await axios.post(apiUrl, {
        prompt: `Create a professional, high-quality image based on this content: ${prompt}`,
        size: '1024x1024',
        style: 'vivid'
      });
      
      if (response.data && response.data.success) {
        const imageData = response.data.data;
        setGeneratedContentImage(imageData.secure_url);
        
        // Save to gallery for future use
        saveImageToGallery({
          id: imageData.public_id,
          url: imageData.url,
          secure_url: imageData.secure_url,
          public_id: imageData.public_id,
          title: 'Generated from YouTube: ' + (youtubeTranscript?.videoId || 'content'),
          tags: ['ai-generated', 'youtube', 'linkedin'],
          uploadedAt: new Date().toISOString(),
          type: 'ai-generated',
          width: imageData.width,
          height: imageData.height
        });
        
        toast.success('Image generated successfully!');
      } else {
        throw new Error(response.data?.message || 'Failed to generate image');
      }
    } catch (error) {
      console.error('Error generating image:', error);
      toast.error('Failed to generate image. Please try again.');
    } finally {
      setIsGeneratingImage(false);
    }
  };

  // Modify the YouTube search handler to accept an optional channelName
  const handleYoutubeSearch = async (channelNameParam?: string) => {
    const searchQuery = channelNameParam || youtubeSearchQuery;
    
    if (!searchQuery.trim()) {
      toast.error('Please enter a search query');
      return;
    }
    
    setIsSearching(true);
    setYoutubeSearchResults([]);
    
    try {
      // Call backend API to search for videos
      const apiUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:5000'}/api/youtube/search`;
      const response = await axios.get(apiUrl, {
        params: { query: searchQuery }
      });
      
      if (response.data && response.data.success) {
        setYoutubeSearchResults(response.data.data);
        toast.success(`Found ${response.data.data.length} videos`);
      } else {
        throw new Error(response.data?.message || 'Failed to search videos');
      }
    } catch (error) {
      console.error('Error searching YouTube videos:', error);
      toast.error('Failed to search for videos. Please try again.');
    } finally {
      setIsSearching(false);
    }
  };

  // Add handler to select a YouTube video from search results
  const handleSelectYoutubeVideo = (video: YouTubeSearchResult) => {
    setInputUrl(`https://www.youtube.com/watch?v=${video.videoId}`);
    setYoutubeSearchResults([]); // Clear search results
    setYoutubeSearchQuery(''); // Clear search query
  };

  // Replace YouTube search handler with channel videos handler
  const handleFetchChannelVideos = async () => {
    if (!channelInput.trim()) {
      toast.error('Please enter a channel name or URL');
      return;
    }
    
    setIsLoadingChannel(true);
    setYoutubeVideos([]);
    setYoutubeTranscript(null); // Clear any previous transcript
    setLinkedinContent(''); // Clear any previous content
    
    try {
      // Fix the API URL to remove duplicate /api/
      const baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:5000';
      // Make sure there's only one /api/ in the path
      const apiBaseUrl = baseUrl.endsWith('/api') ? baseUrl : `${baseUrl}/api`;
      
      console.log('Fetching videos from URL:', `${apiBaseUrl}/youtube/channel-videos`);
      
      // Call backend API to fetch channel videos
      const response = await axios.post(`${apiBaseUrl}/youtube/channel-videos`, {
        channelName: channelInput
      });
      
      if (response.data && response.data.success) {
        setYoutubeVideos(response.data.data);
        
        // Try to extract channel name
        if (response.data.data.length > 0) {
          setChannelName(response.data.data[0].channelName);
        } else if (channelInput.includes('@')) {
          setChannelName('@' + channelInput.split('@')[1].split('/')[0]);
        } else {
          setChannelName(channelInput);
        }
        
        toast.success(`Found ${response.data.data.length} videos from the channel`);
      } else {
        throw new Error(response.data?.message || 'Failed to fetch channel videos');
      }
    } catch (error) {
      console.error('Error fetching channel videos:', error);
      toast.error('Failed to fetch channel videos. Please check the channel name or URL.');
    } finally {
      setIsLoadingChannel(false);
    }
  };

  // Modify the handleSelectVideo to match the example code pattern
  const handleSelectVideo = (video: ChannelVideo) => {
    setInputUrl(video.url);
    // Get the transcript directly after selecting a video
    handleYouTubeScrape(video.url);
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">Content Scraper</h1>
        <p className="text-gray-500 dark:text-gray-400">
          Extract content from various platforms to repurpose for LinkedIn
        </p>
      </div>
      
      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Input Source</CardTitle>
          <CardDescription>
            Enter a URL from your chosen platform
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Tabs
            defaultValue="linkedin"
            value={activeTab}
            onValueChange={value => {
              setActiveTab(value);
              setResult(null);
              setTwitterResult(null);
              setYoutubeTranscript(null);
              setLinkedinContent('');
              setYoutubeSearchResults([]);
            }}
            className="w-full"
          >
            <TabsList className="grid grid-cols-4 w-full mb-6">
              <TabsTrigger value="linkedin" className="flex items-center gap-2">
                <Linkedin className="h-4 w-4" />
                <span className="hidden sm:inline">LinkedIn</span>
              </TabsTrigger>
              <TabsTrigger value="twitter" className="flex items-center gap-2">
                <Twitter className="h-4 w-4" />
                <span className="hidden sm:inline">Twitter</span>
              </TabsTrigger>
              <TabsTrigger value="youtube" className="flex items-center gap-2">
                <Youtube className="h-4 w-4" />
                <span className="hidden sm:inline">YouTube</span>
              </TabsTrigger>
              <TabsTrigger value="web" className="flex items-center gap-2">
                <Globe className="h-4 w-4" />
                <span className="hidden sm:inline">Web</span>
              </TabsTrigger>
            </TabsList>
            
            <div className="flex flex-col sm:flex-row gap-4 mb-4">
              <div className="flex-1">
                <Input
                  type="text"
                  placeholder={
                    activeTab === 'linkedin' ? 'Enter LinkedIn post or article URL' :
                    activeTab === 'twitter' ? 'Enter Twitter username or URL' :
                    activeTab === 'youtube' ? 'Enter YouTube video URL' :
                    'Enter website URL'
                  }
                  value={inputUrl}
                  onChange={(e) => setInputUrl(e.target.value)}
                  className="w-full"
                />
              </div>
              <Button
                onClick={handleScrape}
                disabled={isLoading || !inputUrl}
                className="min-w-[120px]"
              >
                {isLoading ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Loading
                  </>
                ) : (
                  <>
                    <Search className="mr-2 h-4 w-4" />
                    {activeTab === 'twitter' ? 'Fetch Tweets' : 
                     activeTab === 'youtube' ? 'Get Transcript' : 'Scrape Content'}
                  </>
                )}
              </Button>
            </div>
            
            {/* Update YouTube section */}
            {activeTab === 'youtube' && (
              <div className="mt-4 border-t pt-4">
                <p className="text-sm text-gray-500 mb-3">Enter a YouTube channel name or URL to fetch videos:</p>
                <div className="flex flex-col sm:flex-row gap-4">
                  <div className="flex-1">
                    <Input
                      type="text"
                      placeholder="Channel name (e.g., @MrBeast) or URL"
                      value={channelInput}
                      onChange={(e) => setChannelInput(e.target.value)}
                      className="w-full"
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          handleFetchChannelVideos();
                        }
                      }}
                    />
                  </div>
                  <Button
                    onClick={handleFetchChannelVideos}
                    disabled={isLoadingChannel || !channelInput.trim()}
                    className="min-w-[120px]"
                  >
                    {isLoadingChannel ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Loading...
                      </>
                    ) : (
                      <>
                        <Search className="mr-2 h-4 w-4" />
                        Fetch Videos
                      </>
                    )}
                  </Button>
                </div>
                
                {/* Channel videos */}
                {youtubeVideos.length > 0 && (
                  <div className="mt-6">
                    <h3 className="text-lg font-semibold mb-3">
                      {channelName ? `Videos from ${channelName}` : 'Channel Videos'}
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-[600px] overflow-y-auto p-2">
                      {youtubeVideos.map(video => (
                        <Card 
                          key={video.videoId} 
                          className="overflow-hidden cursor-pointer hover:border-primary transition-colors"
                          onClick={() => handleSelectVideo(video)}
                        >
                          <div className="relative aspect-video bg-gray-100">
                            <img 
                              src={video.thumbnail} 
                              alt={video.title}
                              className="w-full h-full object-cover"
                              onError={(e) => {
                                (e.target as HTMLImageElement).src = `https://img.youtube.com/vi/${video.videoId}/mqdefault.jpg`;
                              }}
                            />
                            {video.duration && (
                              <div className="absolute bottom-2 right-2 bg-black/70 text-white text-xs px-1 rounded">
                                {Math.floor(video.duration / 60)}:{(video.duration % 60).toString().padStart(2, '0')}
                              </div>
                            )}
                          </div>
                          <CardContent className="p-3">
                            <h3 className="font-medium text-sm line-clamp-2 mb-1">{video.title}</h3>
                            <div className="flex items-center justify-between">
                              <p className="text-xs text-gray-500">{video.channelName}</p>
                              {video.uploadDate && (
                                <p className="text-xs text-gray-500">
                                  {video.uploadDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3')}
                                </p>
                              )}
                            </div>
                          </CardContent>
                        </Card>
                      ))}
                    </div>
                    <div className="mt-4 text-center">
                      <p className="text-sm text-gray-500">
                        Click on a video to get its transcript
                      </p>
                    </div>
                  </div>
                )}
              </div>
            )}
          </Tabs>
        </CardContent>
      </Card>
      
      {/* Twitter Results Section */}
      {activeTab === 'twitter' && twitterResult && (
        <div className="space-y-6">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-3">
              {twitterResult.profileImageUrl && (
                <img 
                  src={twitterResult.profileImageUrl} 
                  alt={twitterResult.username}
                  className="w-10 h-10 rounded-full" 
                />
              )}
              <div>
                <h3 className="font-semibold">@{twitterResult.username}</h3>
                <p className="text-sm text-gray-500">
                  {twitterResult.tweets.length} tweets scraped
                </p>
              </div>
            </div>
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setSelectedTweets(new Set(twitterResult.tweets.map(t => t.id)))}
                disabled={isLoading}
              >
                Select All
              </Button>
              <Button
                variant="outline" 
                size="sm"
                onClick={() => setSelectedTweets(new Set())}
                disabled={isLoading || selectedTweets.size === 0}
              >
                Clear Selection
              </Button>
              <Button
                variant="default"
                size="sm"
                onClick={handleSaveSelectedTweets}
                disabled={isLoading || selectedTweets.size === 0}
                className="gap-2"
              >
                {isLoading ? (
                  <>
                    <Loader2 className="h-3 w-3 animate-spin" />
                    Saving...
                  </>
                ) : (
                  <>
                    <Save className="h-3 w-3" />
                    Save Selected ({selectedTweets.size})
                  </>
                )}
              </Button>
            </div>
          </div>
          
          <div className="space-y-4">
            {twitterResult.tweets.map(tweet => (
              <Card key={tweet.id} className={`overflow-hidden ${selectedTweets.has(tweet.id) ? 'border-primary' : ''}`}>
                <CardHeader className="p-4 pb-2 flex flex-row justify-between">
                  <div>
                    <div className="flex items-center gap-2 mb-1">
                      <img 
                        src={tweet.author.profile_image_url} 
                        alt={tweet.author.name}
                        className="w-8 h-8 rounded-full" 
                      />
                      <div>
                        <CardTitle className="text-base">{tweet.author.name}</CardTitle>
                        <CardDescription className="text-xs">@{tweet.author.username}</CardDescription>
                      </div>
                    </div>
                    <CardDescription className="text-xs">
                      {new Date(tweet.created_at).toLocaleDateString()}
                    </CardDescription>
                  </div>
                  <div>
                    <Button
                      variant={selectedTweets.has(tweet.id) ? "secondary" : "ghost"}
                      size="sm"
                      onClick={() => handleToggleTweetSelection(tweet.id)}
                      className="h-8 w-8 p-0"
                    >
                      {selectedTweets.has(tweet.id) ? (
                        <div className="h-5 w-5 rounded-sm bg-primary text-primary-foreground flex items-center justify-center">
                          ✓
                        </div>
                      ) : (
                        <div className="h-5 w-5 rounded-sm border border-input"></div>
                      )}
                    </Button>
                  </div>
                </CardHeader>
                <CardContent className="p-4 pt-2">
                  <p className="whitespace-pre-line text-sm">
                    {tweet.full_text || tweet.text}
                  </p>
                  
                  {tweet.media && tweet.media.length > 0 && (
                    <div className="mt-3 grid grid-cols-2 gap-2">
                      {tweet.media.map((media, index) => (
                        media.type === 'photo' && (
                          <div key={media.media_key || index} className="rounded overflow-hidden">
                            <img 
                              src={media.url} 
                              alt={media.alt_text || 'Tweet media'} 
                              className="w-full h-auto"
                            />
                          </div>
                        )
                      ))}
                    </div>
                  )}
                </CardContent>
                <CardFooter className="p-3 border-t flex justify-between bg-gray-50">
                  <div className="flex items-center gap-6 text-xs text-gray-500">
                    <div className="flex items-center gap-1">
                      <MessageSquare className="h-3 w-3" />
                      {tweet.public_metrics.reply_count}
                    </div>
                    <div className="flex items-center gap-1">
                      <svg className="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                      </svg>
                      {tweet.public_metrics.retweet_count}
                    </div>
                    <div className="flex items-center gap-1">
                      <svg className="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                      </svg>
                      {tweet.public_metrics.like_count}
                    </div>
                  </div>
                  <Button variant="ghost" size="sm" onClick={() => handleCopy(tweet.full_text || tweet.text)}>
                    <Copy className="h-3 w-3 mr-1" />
                    Copy
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
        </div>
      )}
      
      {/* YouTube Transcript Results */}
      {youtubeTranscript && (
        <div className="mt-8">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center">
                <Youtube className="mr-2 h-5 w-5" />
                YouTube Transcript
              </CardTitle>
              <CardDescription>
                Video ID: {youtubeTranscript.videoId} | 
                Language: {youtubeTranscript.language} | 
                {youtubeTranscript.isAutoGenerated ? 'Auto-generated' : 'Manual Captions'}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div>
                  <h3 className="text-lg font-semibold mb-3">Transcript</h3>
                  <div className="bg-gray-50 dark:bg-gray-900 p-4 rounded-md max-h-[400px] overflow-y-auto">
                    <p className="whitespace-pre-line text-sm">
                      {youtubeTranscript.transcript}
                    </p>
                  </div>
                  <div className="flex justify-between mt-4">
                    <Button
                      variant="outline"
                      onClick={() => handleCopy(youtubeTranscript.transcript)}
                      className="gap-2"
                    >
                      <Copy className="h-4 w-4" />
                      Copy Transcript
                    </Button>
                    <Button
                      variant="secondary"
                      onClick={handleSaveToInspiration}
                      className="gap-2"
                    >
                      <Lightbulb className="h-4 w-4" />
                      Save to Inspiration
                    </Button>
                    <Button
                      variant="outline"
                      onClick={() => navigate('/dashboard/images')}
                      className="gap-2"
                    >
                      <ImageIcon className="h-4 w-4" />
                      Image Gallery
                    </Button>
                  </div>
                </div>
                
                <div>
                  <h3 className="text-lg font-semibold mb-3">Generate LinkedIn Content</h3>
                  <div className="space-y-4">
                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <label className="block text-sm font-medium mb-1">Format</label>
                        <select
                          className="w-full p-2 border border-gray-300 dark:border-gray-700 rounded-md"
                          value={contentPreferences.format}
                          onChange={(e) => setContentPreferences({
                            ...contentPreferences,
                            format: e.target.value
                          })}
                        >
                          <option value="short">Short Post</option>
                          <option value="long">Long Post</option>
                          <option value="carousel">Carousel</option>
                          <option value="article">Article Outline</option>
                        </select>
                      </div>
                      <div>
                        <label className="block text-sm font-medium mb-1">Tone</label>
                        <select
                          className="w-full p-2 border border-gray-300 dark:border-gray-700 rounded-md"
                          value={contentPreferences.tone}
                          onChange={(e) => setContentPreferences({
                            ...contentPreferences,
                            tone: e.target.value
                          })}
                        >
                          <option value="professional">Professional</option>
                          <option value="conversational">Conversational</option>
                          <option value="educational">Educational</option>
                          <option value="enthusiastic">Enthusiastic</option>
                          <option value="thought-leadership">Thought Leadership</option>
                        </select>
                      </div>
                    </div>
                    
                    <Button
                      onClick={handleAnalyzeTranscript}
                      disabled={isAnalyzing}
                      className="w-full gap-2"
                    >
                      {isAnalyzing ? (
                        <>
                          <Loader2 className="h-4 w-4 animate-spin" />
                          Generating Content...
                        </>
                      ) : (
                        <>
                          <MessageSquare className="h-4 w-4" />
                          Generate LinkedIn Content
                        </>
                      )}
                    </Button>
                    
                    {linkedinContent && (
                      <div className="mt-4">
                        <h4 className="text-md font-medium mb-2">LinkedIn Content</h4>
                        <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 p-4 rounded-md max-h-[250px] overflow-y-auto">
                          <p className="whitespace-pre-line">
                            {linkedinContent}
                          </p>
                        </div>
                        <div className="flex justify-between mt-4">
                          <Button
                            variant="outline"
                            onClick={() => handleCopy(linkedinContent)}
                            className="gap-2"
                          >
                            <Copy className="h-4 w-4" />
                            Copy Content
                          </Button>
                          <Button
                            onClick={handleCreatePost}
                            className="gap-2"
                          >
                            <ArrowRight className="h-4 w-4" />
                            Create Post
                          </Button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
      
      {/* Results section - Original content for LinkedIn/Website/YouTube */}
      {activeTab !== 'twitter' && result && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* Left column - Extracted content */}
          <div className="md:col-span-2">
            <Card>
              <CardHeader>
                <CardTitle>Extracted Content</CardTitle>
                <CardDescription>
                  Content extracted from {activeTab === 'linkedin' 
                    ? 'LinkedIn' 
                    : activeTab === 'website' 
                      ? 'website' 
                      : 'YouTube video'}
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="border border-gray-200 dark:border-gray-800 rounded-lg p-4 mb-4 bg-white dark:bg-gray-900">
                  <p className="text-gray-700 dark:text-gray-300 whitespace-pre-line">
                    {result.content}
                  </p>
                </div>
                
                <Accordion type="single" collapsible className="mb-4">
                  <AccordionItem value="key-points">
                    <AccordionTrigger className="text-base font-medium">
                      Key Points
                    </AccordionTrigger>
                    <AccordionContent>
                      <ul className="list-disc pl-5 space-y-2">
                        {result.keyPoints.map((point, index) => (
                          <li key={index} className="text-gray-700 dark:text-gray-300">
                            {point}
                          </li>
                        ))}
                      </ul>
                    </AccordionContent>
                  </AccordionItem>
                </Accordion>
                
                <div className="grid grid-cols-2 gap-4">
                  <div className="border border-gray-200 dark:border-gray-800 rounded-lg p-3">
                    <div className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                      Detected Tone
                    </div>
                    <div className="text-gray-700 dark:text-gray-300">
                      {result.tone}
                    </div>
                  </div>
                  <div className="border border-gray-200 dark:border-gray-800 rounded-lg p-3">
                    <div className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                      Details
                    </div>
                    <div className="text-gray-700 dark:text-gray-300 flex flex-col gap-1">
                      <div className="flex items-center justify-between">
                        <span>Word count:</span>
                        <span>{result.wordCount}</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span>Read time:</span>
                        <span>{result.estimatedReadTime} min</span>
                      </div>
                    </div>
                  </div>
                </div>
              </CardContent>
              <CardFooter className="flex justify-between border-t border-gray-200 dark:border-gray-800 pt-4">
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="gap-1"
                  onClick={() => handleCopy(result.content)}
                >
                  <Copy className="h-4 w-4" />
                  Copy Content
                </Button>
                
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="gap-1"
                  onClick={handleSaveToInspiration}
                >
                  <Save className="h-4 w-4" />
                  Save to Vault
                </Button>
              </CardFooter>
            </Card>
          </div>
          
          {/* Right column - AI suggestions */}
          <div>
            {/* Suggested Hook */}
            <Card className="mb-6">
              <CardHeader className="pb-3">
                <CardTitle className="flex items-center gap-2 text-base">
                  <Lightbulb className="h-4 w-4 text-amber-500" />
                  Suggested Hook
                </CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-700 dark:text-gray-300 text-sm mb-3">
                  {result.suggestedHook}
                </p>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="w-full gap-1"
                  onClick={() => handleCopy(result.suggestedHook)}
                >
                  <Copy className="h-4 w-4" />
                  Copy Hook
                </Button>
              </CardContent>
            </Card>
            
            {/* Actions */}
            <Card className="bg-primary-50 dark:bg-primary-900/20">
              <CardHeader className="pb-3">
                <CardTitle className="text-base">
                  Generate LinkedIn Post
                </CardTitle>
              </CardHeader>
              <CardContent className="pb-3">
                <p className="text-sm text-gray-700 dark:text-gray-300 mb-4">
                  Use the extracted content to create an engaging LinkedIn post with AI assistance.
                </p>
                
                <Button 
                  className="w-full gap-2 mb-3"
                  onClick={handleCreatePost}
                >
                  <PlusCircle className="h-4 w-4" />
                  Create Post
                </Button>
                
                <Button 
                  variant="outline"
                  className="w-full gap-2"
                  onClick={() => navigate('/dashboard/ai')}
                >
                  <MessageSquare className="h-4 w-4" />
                  Expand with AI Writer
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>
      )}
      
      {/* Instructions when no result */}
      {!result && !isLoading && (
        <Card>
          <CardContent className="pt-6">
            <div className="text-center max-w-xl mx-auto">
              <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary-50 dark:bg-primary-900/20 mb-4">
                {activeTab === 'linkedin' ? (
                  <Linkedin className="h-8 w-8 text-primary" />
                ) : activeTab === 'website' ? (
                  <Globe className="h-8 w-8 text-primary" />
                ) : activeTab === 'twitter' ? (
                  <Twitter className="h-8 w-8 text-primary" />
                ) : (
                  <Youtube className="h-8 w-8 text-primary" />
                )}
              </div>
              
              <h3 className="text-lg font-medium mb-2">
                {activeTab === 'linkedin' 
                  ? 'Extract Content from LinkedIn' 
                  : activeTab === 'website'
                    ? 'Extract Content from Websites'
                    : activeTab === 'twitter'
                      ? 'Extract Content from Twitter'
                    : 'Extract Content from YouTube Videos'
                }
              </h3>
              
              <p className="text-gray-500 dark:text-gray-400 mb-6">
                {activeTab === 'linkedin' 
                  ? 'Paste a LinkedIn profile URL or post link to extract professional insights, experience, and content for your posts.' 
                  : activeTab === 'website'
                    ? 'Paste any article or blog URL to extract key points, analyze tone, and suggest hooks for your LinkedIn content.'
                    : activeTab === 'twitter'
                      ? 'Paste a Twitter username or profile URL to extract tweets and insights for your LinkedIn content.'
                    : 'Paste a YouTube video URL to extract transcripts, key points, and insights to share on LinkedIn.'
                }
              </p>
              
              <div className="flex flex-col space-y-2">
                <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                  <div className="flex-shrink-0 w-6 h-6 rounded-full bg-primary-100 dark:bg-primary-900/30 flex items-center justify-center text-xs font-medium">
                    1
                  </div>
                  <span>Enter the URL in the input field above</span>
                </div>
                
                <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                  <div className="flex-shrink-0 w-6 h-6 rounded-full bg-primary-100 dark:bg-primary-900/30 flex items-center justify-center text-xs font-medium">
                    2
                  </div>
                  <span>Click "Scrape" to extract content</span>
                </div>
                
                <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                  <div className="flex-shrink-0 w-6 h-6 rounded-full bg-primary-100 dark:bg-primary-900/30 flex items-center justify-center text-xs font-medium">
                    3
                  </div>
                  <span>Review and use the extracted content for your LinkedIn posts</span>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Generated Image Section */}
      {linkedinContent && (
        <div className="mt-4">
          <h4 className="text-md font-medium mb-2">Generated Image</h4>
          <div className="flex justify-between mt-4">
            <Button
              variant="outline"
              onClick={handleGenerateImageFromContent}
              disabled={isGeneratingImage}
              className="gap-2"
            >
              {isGeneratingImage ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Generating Image...
                </>
              ) : (
                <>
                  <ImageIcon className="h-4 w-4" />
                  Generate Image
                </>
              )}
            </Button>
          </div>
          
          {generatedContentImage && (
            <div className="mt-4">
              <div className="relative rounded-md overflow-hidden">
                <img 
                  src={generatedContentImage} 
                  alt="Generated image"
                  className="w-full max-h-[250px] object-cover"
                />
              </div>
              <div className="flex justify-between mt-2">
                <Button
                  variant="outline"
                  onClick={() => navigate('/dashboard/images')}
                  className="gap-2"
                >
                  <Folder className="h-4 w-4" />
                  View in Gallery
                </Button>
                <Button
                  onClick={() => navigate('/dashboard/post', { 
                    state: { 
                      content: linkedinContent, 
                      image: generatedContentImage 
                    } 
                  })}
                  className="gap-2"
                >
                  <ArrowRight className="h-4 w-4" />
                  Create Post with Image
                </Button>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default ScraperPage; 